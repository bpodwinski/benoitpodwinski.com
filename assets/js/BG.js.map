{"version":3,"sources":["BG.js"],"names":["BG","groupHolder","cubeMesh","cubeShader","update","onBeat","init","events","on","THREE","Object3D","VizHandler","getScene","add","cubeMap","Assets","getCubeMap","ShaderLib","uniforms","value","skyBoxMaterial","ShaderMaterial","fragmentShader","vertexShader","depthWrite","side","BackSide","Mesh","CubeGeometry","cubeMaterial","MeshStandardMaterial","shading","FlatShading","PlaneGeometry","rotation","x","Math","PI","position","y","castShadow","receiveShadow","test","setEnvMap"],"mappings":"AAAA,IAAIA,GAAK,WAEL,IAAIC,EAOAC,EAAUC,EAkHd,SAASC,KAOT,SAASC,KA0BT,MAAO,CACHC,KAlJJ,WAKIC,OAAOC,GAAG,SAAUJ,GACpBG,OAAOC,GAAG,SAAUH,GAGpBJ,EAAc,IAAIQ,MAAMC,SACxBC,WAAWC,WAAWC,IAAIZ,GAI1Ba,QAAUC,OAAOC,WAFD,KAIhBb,EAAaM,MAAMQ,UAAgB,MACxBC,SAAgB,MAAEC,MAAQL,QAErC,IAAIM,EAAiB,IAAIX,MAAMY,eAAe,CAC1CC,eAAgBnB,EAAWmB,eAC3BC,aAAcpB,EAAWoB,aACzBL,SAAUf,EAAWe,SACrBM,YAAY,EACZC,KAAMhB,MAAMiB,WAGH,IAAIjB,MAAMkB,KACf,IAAIlB,MAAMmB,aAAa,KAAM,KAAM,MACnCR,GAMRS,aAAe,IAAIpB,MAAMqB,qBAAqB,CAC1CC,QAAStB,MAAMuB,eAQnB9B,EAAW,IAAIO,MAAMkB,KAAK,IAAIlB,MAAMwB,cAAc,GAAI,IAAKJ,eAClDK,SAASC,GAAKC,KAAKC,GAAK,EACjCnC,EAASoC,SAASC,GAAK,IACvBrC,EAASsC,YAAa,EACtBtC,EAASuC,eAAgB,EACzBxC,EAAYY,IAAIX,GAEhB,IAAIwC,EAAO,IAAIjC,MAAMkB,KACb,IAAIlB,MAAMmB,aAAa,GAAI,GAAI,IAC/BC,cAIRa,EAAKF,YAAa,EAClBE,EAAKD,eAAgB,GAyFrBrC,OAAQA,EACRC,OAAQA,EACRsC,UARJ,SAAmB7B,GACfX,EAAWe,SAAgB,MAAEC,MAAQL,IAzJpC","file":"BG.js","sourcesContent":["var BG = function () {\r\n\r\n    var groupHolder;\r\n    var material;\r\n    var planeMaterial\r\n    var spd = 0;\r\n\r\n    var shapes = [];\r\n\r\n    var cubeMesh, cubeShader;\r\n\r\n    function init() {\r\n\r\n        //console.log(\"BG\")\r\n\r\n        //init event listeners\r\n        events.on(\"update\", update);\r\n        events.on(\"onBeat\", onBeat);\r\n\r\n\r\n        groupHolder = new THREE.Object3D();\r\n        VizHandler.getScene().add(groupHolder);\r\n\r\n        var cubeMapId = 23//4//28//23//20//16//7;//9\r\n        //4,,23,16,9,,28,20\r\n        cubeMap = Assets.getCubeMap(cubeMapId)\r\n\r\n        cubeShader = THREE.ShaderLib['cube'];\r\n        cubeShader.uniforms['tCube'].value = cubeMap;\r\n\r\n        var skyBoxMaterial = new THREE.ShaderMaterial({\r\n            fragmentShader: cubeShader.fragmentShader,\r\n            vertexShader: cubeShader.vertexShader,\r\n            uniforms: cubeShader.uniforms,\r\n            depthWrite: true,\r\n            side: THREE.BackSide\r\n        });\r\n\r\n        var skyBox = new THREE.Mesh(\r\n                new THREE.CubeGeometry(1500, 1500, 1500),\r\n                skyBoxMaterial\r\n                //new THREE.MeshBasicMaterial({color:0xFFFFFF,side: THREE.BackSide})\r\n                );\r\n\r\n        //groupHolder.add(skyBox);\r\n\r\n        cubeMaterial = new THREE.MeshStandardMaterial({\r\n            shading: THREE.FlatShading,\r\n            //envMap: reflectionCube,\r\n            //side: THREE.DoubleSide,\r\n            //depthWrite:false,\r\n            //depthTest:false,\r\n            //blendEquation:THREE.MinEquation\r\n        })\r\n\r\n        cubeMesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), cubeMaterial);\r\n        cubeMesh.rotation.x = -Math.PI / 2\r\n        cubeMesh.position.y = -.25;\r\n        cubeMesh.castShadow = true;\r\n        cubeMesh.receiveShadow = true;\r\n        groupHolder.add(cubeMesh);\r\n\r\n        var test = new THREE.Mesh(\r\n                new THREE.CubeGeometry(.2, .2, .2),\r\n                cubeMaterial\r\n                //new THREE.MeshBasicMaterial({color:0xFFFFFF,side: THREE.BackSide})\r\n                );\r\n\r\n        test.castShadow = true;\r\n        test.receiveShadow = true;\r\n        //groupHolder.add(test);\r\n\r\n\r\n        /*planeMaterial = new THREE.MeshPhongMaterial({\r\n         envMap: Assets.textureCube(),\r\n         reflectivity: 1,\r\n         //opacity:.3,//.75,\r\n         color: 0xffffff,\r\n         //transparent:true,\r\n         shading: THREE.FlatShading,\r\n         //blending: THREE.AdditiveBlending,\r\n         side: THREE.DoubleSide//BackSide\r\n         });\r\n         \r\n         \r\n         var groundGeometry = new THREE.PlaneGeometry(4000, 8000, 10, 10);\r\n         var vert = groundGeometry.vertices\r\n         for (var i = 0; i < vert.length; i++) {\r\n         vert[i].z += Math.random() * 1000\r\n         }\r\n         groundGeometry.verticesNeedUpdate = true;\r\n         groundGeometry.normalsNeedUpdate = true;\r\n         groundGeometry.computeFaceNormals();\r\n         groundGeometry.computeVertexNormals();\r\n         \r\n         var ground = new THREE.Mesh(groundGeometry, planeMaterial);\r\n         ground.position.x = -2000;\r\n         ground.position.y = -1500;\r\n         ground.rotation.x = -Math.PI / 2\r\n         //groupHolder.add( ground );\r\n         \r\n         \r\n         var groundGeometry = new THREE.PlaneGeometry(4000, 8000, 10, 10);\r\n         for (var i = 0; i < vert.length; i++) {\r\n         groundGeometry.vertices[i].x = -vert[i].x\r\n         groundGeometry.vertices[i].y = vert[i].y\r\n         groundGeometry.vertices[i].z = vert[i].z\r\n         }\r\n         groundGeometry.verticesNeedUpdate = true;\r\n         groundGeometry.normalsNeedUpdate = true;\r\n         groundGeometry.computeFaceNormals();\r\n         groundGeometry.computeVertexNormals();\r\n         \r\n         var ground2 = new THREE.Mesh(groundGeometry, planeMaterial);\r\n         ground2.position.x = 2000;\r\n         ground2.position.y = -1500;\r\n         ground2.rotation.x = -Math.PI / 2\r\n         //groupHolder.add( ground2 );\r\n         */\r\n\r\n\r\n    }\r\n\r\n    function update() {\r\n\r\n        //cubeMesh.rotation.x += spd * .001\r\n        //cubeMesh.scale.x = cubeMesh.scale.y = cubeMesh.scale.z = 16 - ControlsHandler.fxParams.bgProgress * 8\r\n        //groupHolder.rotation.z+=.001\r\n    }\r\n\r\n    function onBeat() {\r\n        /*if (Math.random() < .05)\r\n         spd = (Math.random() - .5)\r\n         \r\n         if (ControlsHandler.fxParams.wireframe) {\r\n         cubeMesh.material.wireframe = true;\r\n         planeMaterial.wireframe = true;\r\n         } else {\r\n         cubeMesh.material.wireframe = false;\r\n         planeMaterial.wireframe = false;\r\n         }\r\n         \r\n         \r\n         var basic = [ControlsHandler.fxParams.colorProgress * .75, ControlsHandler.fxParams.colorProgress * .75, (1 - ControlsHandler.fxParams.colorProgress) * .5]\r\n         cubeMesh.material.color.setRGB(basic[0] + Math.random() / 2, basic[1] + Math.random() / 2, basic[2] + Math.random() / 2);\r\n         planeMaterial.color.setRGB(basic[0] + Math.random() / 2, basic[1] + Math.random() / 2, basic[2] + Math.random() / 2);\r\n         if (ControlsHandler.fxParams.black) {\r\n         cubeMesh.material.color.setRGB(.2, .2, .2);\r\n         planeMaterial.color.setRGB(.2, .2, .2);\r\n         }*/\r\n    }\r\n\r\n    function setEnvMap(cubeMap) {\r\n        cubeShader.uniforms['tCube'].value = cubeMap;\r\n    }\r\n\r\n    return {\r\n        init: init,\r\n        update: update,\r\n        onBeat: onBeat,\r\n        setEnvMap: setEnvMap\r\n    };\r\n\r\n}();"]}